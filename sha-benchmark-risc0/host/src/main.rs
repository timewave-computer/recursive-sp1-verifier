// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
fn main() {}

#[cfg(test)]
mod tests {
    use methods::{SHA_BENCH_ELF, SHA_BENCH_ID};
    use risc0_zkvm::{default_prover, ExecutorEnv, ProverOpts};
    use std::time::Instant;
    use types::{SmtOpeningBatch, SmtOpeningInput};
    use valence_smt::MemorySmt;
    #[test]
    fn test_smt_zk_proof_batch() {
        let proof_count = 254;
        let start_time = Instant::now();

        let context = "poem";
        let mut data: Vec<[u8; 3]> = vec![[0x00, 0x00, 0x00]];
        for i in 1..proof_count {
            data.push([0x00, 0x00, i as u8]);
        }

        let mut tree = MemorySmt::default();

        let mut inserts = 0;
        let mut root = [0; 32];
        for entry in data.clone() {
            inserts += 1;
            root = tree.insert(root, context, entry.to_vec()).unwrap();
        }
        assert_eq!(inserts, proof_count);
        let mut proofs = vec![];
        for entry in data {
            proofs.push(tree.get_opening(context, root, &entry).unwrap().unwrap());
        }

        assert_eq!(proofs.len(), proof_count);

        let mut proof_batch = SmtOpeningBatch { proofs: vec![] };
        for proof in proofs {
            proof_batch.proofs.push(SmtOpeningInput {
                proof_serialized: borsh::to_vec(&proof).unwrap(),
                root,
                context: context.to_string(),
            });
        }
        assert_eq!(proof_batch.proofs.len(), proof_count);
        let proof_batch_serialized = borsh::to_vec(&proof_batch).unwrap();
        let env = ExecutorEnv::builder()
            .write_slice(&proof_batch_serialized)
            .build()
            .unwrap();

        let prover = default_prover();
        let prove_info = prover
            .prove_with_opts(env, SHA_BENCH_ELF, &ProverOpts::default()) //&ProverOpts::groth16())
            .unwrap();
        let receipt = prove_info.receipt;
        receipt.verify(SHA_BENCH_ID).unwrap();

        let end_time = Instant::now() - start_time;
        println!("Time taken: {:?}", end_time);
    }
}
